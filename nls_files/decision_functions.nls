;; f, g, h -> procedures
to compose-decision [ f g h ]
  
  ask searchers with [ who != [ who ] of searcher-zero ]
  [
    let f_result runresult f
    let g_result runresult g
    
    set df ( runresult h f_result g_result )    
  ]
  
end

to-report get-decision 
  
  report max-one-of searchers with [ who != [ who ] of searcher-zero ] [ df ]
  
end

to-report score-function-preferred [ main-searcher object-set ]
  
  let closest-object-to-me ( get-closest-object-to-agent object-set self )
      
  let closest_patch_distance ifelse-value ( closest-object-to-me != nobody ) [ distance closest-object-to-me ] [ max-distance ]
  let heading_diff ( abs ( subtract-headings [ heading ] of main-searcher heading ) )
      
  report ( get-df scope-radius closest_patch_distance heading_diff )
  
end

to-report agent-distance-to-goal [ goal ]
  
  if goal = nobody
  [ report 0 ]
  
  report distance goal
  
end

to-report one-through-x [ x ]
   
  if (x = 0)
  [ report 0 ]
  
  report 1 / x
  
end

to-report get-temp-object-set 

  report patches with [ pcolor <= memory-pcolor-max and pcolor >= memory-pcolor-min and distance searcher-zero <= area-of-interest-r ]

end

to-report get-closest-object-to-agent [ temp-object-set _agent ]
  
  report min-one-of temp-object-set [ distance _agent ]
  
end

to-report get-df [ scope_radius closest_patch_distance heading_diff ]
  
  let norm-distance-f ifelse-value ( normalize-distance-with = "default") [ task [ normalize-closest-patch-distance closest_patch_distance ] ] 
  [ 
    ifelse-value ( normalize-distance-with = "circle area" ) 
    [ task [ normalize-closest-patch-distance-with-circle-area closest_patch_distance scope_radius ] ] 
    [
      ifelse-value ( normalize-distance-with = "rpi" ) 
      [ task [ normalize-closest-patch-distance-with-rpi closest_patch_distance scope_radius ] ] 
      [ task [ normalize-closest-patch-distance-with-max-distance closest_patch_distance ] ]
    ] 
  ]
  
  let norm-closest-patch-distance ( run-result norm-distance-f )
  
  ;let norm-closest-patch-distance ( normalize-closest-patch-distance closest_patch_distance )
  let norm-deflection-angle-value ( normalize-deflection-angle       ( abs heading_diff ) )
  
  report ( weight-param-a * norm-closest-patch-distance ) - ( weight-param-b * norm-deflection-angle-value )
    
end

to-report get-max-distance
  
  report sqrt ( max-pxcor ^ 2 + max-pycor ^ 2 ) 
  
end

to-report normalize-closest-patch-distance [ value ]
  
  let norm ( value - minn ) / ( maxx - minn ) 
  
  if norm > 1
  [
    user-message ( word ( minn <= value and value <= maxx ) "\n" value "\n" m "\n" norm "\n" max-dis "\n" minn "\n" maxx "\n" max-dis )
  ]
  
  record-normalized-distance norm 
  
  report norm
  
end

to-report normalize-deflection-angle [ value ]
  
;  ;set dis-headings fput ( value / 180 ) dis-headings
  
  record-normalized-heading ( value / 180 )
  
  report value / 180
  
end

to-report score-function-default [ main-searcher object-set ]
  
  let closest-object-to-me ( get-closest-object-to-agent object-set self )
    
  let diff abs ( subtract-headings [heading] of searcher-zero [heading] of self )  
    
  let comparison-set other searchers with [ who != [ who ] of searcher-zero ]
    
  report ( distance closest-object-to-me ) * ifelse-value ( count comparison-set with [ abs ( subtract-headings [heading] of searcher-zero [heading] of self ) < diff ] < 3 ) [ 1 ] [ -1 ] 
    
end

