;; f, g, h -> procedures
to compose-decision [ f g h ]
  
  ask searchers with [ who != [ who ] of searcher-zero ]
  [
    let f_result runresult f
    let g_result runresult g
    
    set df ( runresult h f_result g_result )    
  ]
  
end

to-report get-decision 
  
  report max-one-of searchers with [ who != [ who ] of searcher-zero ] [ df ]
  
end

to-report linear-decision-function [ main_searcher object_set ]
  
  let closest-object-to-me ( get-closest-object-to-agent object_set self )
      
  let closest_patch_distance ( distance closest-object-to-me ) 
  let heading_diff ( abs ( subtract-headings [ heading ] of main_searcher heading ) )
      
  report ( get-df scope-radius closest_patch_distance heading_diff )
  
end

to-report agent-distance-to-goal [goal]
  
  if goal = nobody
  [ report 0 ]
  
  report distance goal
  
end

to-report one-through-x [x]
  
  if (x = 0)
  [ report 0 ]
  
  report 1 / x
  
end

to-report get-temp-object-set 

  report patches with [ pcolor <= memory-pcolor-max and pcolor >= memory-pcolor-min ]

end

to-report get-closest-object-to-agent [ temp-object-set agent ]
  
  report min-one-of temp-object-set [ distance agent ]
  
end

to-report get-df [ scope_radius closest_patch_distance heading_diff ]
  
  let norm-closest-patch-distance ( normalize-closest-patch-distance closest_patch_distance scope_radius )
  let norm-deflection-angle-value ( normalize-deflection-angle       ( abs heading_diff ) )
  
  report ( weight-param-a * norm-closest-patch-distance - weight-param-b * norm-deflection-angle-value )
    
end

to-report normalize-closest-patch-distance [ value scope_radius ]
  
  report value / ( 2 * scope_radius )
  
end

to-report normalize-deflection-angle [ value ]
  
  report value / 180
  
end

to-report decision-default
  
  let temp-object-set patches with [ pcolor <= memory-pcolor-max and pcolor >= memory-pcolor-min ]
    
  ask searcher-set
  [
    let closest-object-to-me min-one-of temp-object-set [ distance myself ]
      
    set closest-patch-distance ( distance closest-object-to-me )
  ]
    
  let min-searcher-set searcher-set
    
  ifelse ( count searcher-set >= 3 )
  [ set min-searcher-set min-n-of 3 searcher-set [ abs ( subtract-headings [heading] of searcher-zero [heading] of self ) ] ]
  [ set min-searcher-set min-n-of ( count searcher-set ) searcher-set [ abs ( subtract-headings [heading] of searcher-zero [heading] of self ) ] ]
    
  report max-one-of min-searcher-set [ closest-patch-distance ]
  
end

